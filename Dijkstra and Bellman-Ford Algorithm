package asm;
  
import java.util.*;

public class ASM {

    static final int INF = 99999; // Consistent with document's INF convention

    // Dijkstra's Algorithm
    public static void dijkstra(int[][] graph, int src) {
        int n = graph.length;
        int[] dist = new int[n];
        boolean[] visited = new boolean[n];
        
        // Initialize distances
        Arrays.fill(dist, INF);
        dist[src] = 0;
        
        // Priority queue to select vertex with minimum distance
        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
        pq.add(new int[]{src, 0});
        
        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int u = current[0];
            
            if (visited[u]) continue;
            visited[u] = true;
            
            // Update distances to neighbors
            for (int v = 0; v < n; v++) {
                if (!visited[v] && graph[u][v] != INF) {
                    int newDist = dist[u] + graph[u][v];
                    if (newDist < dist[v]) {
                        dist[v] = newDist;
                        pq.add(new int[]{v, newDist});
                    }
                }
            }
        }
        
        // Print results in a format similar to document's Table 14
        System.out.println("Dijkstra's Algorithm Results:");
        System.out.println("Vertex\tDistance from Source");
        for (int i = 0; i < n; i++) {
            char vertex = (char) ('A' + i); // Convert 0,1,2,3 to A,B,C,D
            String distance = (dist[i] == INF) ? "∞" : String.valueOf(dist[i]);
            System.out.println(vertex + "\t" + distance);
        }
    }
    
    // Bellman-Ford Algorithm
    public static void bellmanFord(int[][] graph, int src) {
        int n = graph.length;
        int[] dist = new int[n];
        
        // Initialize distances
        Arrays.fill(dist, INF);
        dist[src] = 0;
        
        // Relax all edges |V|-1 times
        for (int i = 0; i < n - 1; i++) {
            for (int u = 0; u < n; u++) {
                for (int v = 0; v < n; v++) {
                    if (graph[u][v] != INF && dist[u] != INF) {
                        int newDist = dist[u] + graph[u][v];
                        if (newDist < dist[v]) {
                            dist[v] = newDist;
                        }
                    }
                }
            }
        }
        
        // Check for negative-weight cycles
        for (int u = 0; u < n; u++) {
            for (int v = 0; v < n; v++) {
                if (graph[u][v] != INF && dist[u] != INF && dist[u] + graph[u][v] < dist[v]) {
                    System.out.println("Error: Graph contains negative-weight cycle");
                    return;
                }
            }
        }
        
        // Print results in a format similar to document's Table 14
        System.out.println("Bellman-Ford Algorithm Results:");
        System.out.println("Vertex\tDistance from Source");
        for (int i = 0; i < n; i++) {
            char vertex = (char) ('A' + i); // Convert 0,1,2,3 to A,B,C,D
            String distance = (dist[i] == INF) ? "∞" : String.valueOf(dist[i]);
            System.out.println(vertex + "\t" + distance);
        }
    }
    
    public static void main(String[] args) {
        // Graph from document (A=0, B=1, C=2, D=3)
        int[][] graph = {
            {0, 1, 4, INF},    // A -> B=1, A -> C=4
            {INF, 0, 3, 2},    // B -> C=3, B -> D=2
            {INF, INF, 0, INF}, // C has no outgoing edges
            {INF, INF, INF, 0}  // D has no outgoing edges
        };
        
        // Run Dijkstra's algorithm
        System.out.println("=== Running Dijkstra's Algorithm ===");
        dijkstra(graph, 0); // Source is A (vertex 0)
        
        // Separator for clarity
        System.out.println();
        
        // Run Bellman-Ford algorithm
        System.out.println("=== Running Bellman-Ford Algorithm ===");
        bellmanFord(graph, 0); // Source is A (vertex 0)
    }
}
